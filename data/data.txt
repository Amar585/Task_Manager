Getting Help

el

es

fr

id

it

ja

ko

pl

pt-br

zh-hans

Language: en

1.8

1.10

1.11

2.0

2.1

2.2

3.0

3.1

3.2

4.0

4.1

5.0

5.1

5.2

dev

Documentation version: 4.2

Models¶

A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table.

The basics:

Each model is a Python class that subclasses django.db.models.Model.

Each attribute of the model represents a database field.

With all of this, Django gives you an automatically-generated database-access API; see Making queries.

Quick example¶

This example model defines a Person, which has a first_name and last_name:

from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

first_name and last_name are fields of the model. Each field is specified as a class attribute, and each attribute maps to a database column.

The above Person model would create a database table like this:

CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);

Some technical notes:

The name of the table, myapp_person, is automatically derived from some model metadata but can be overridden. See Table names for more details.

An id field is added automatically, but this behavior can be overridden. See Automatic primary key fields.

The CREATE TABLE SQL in this example is formatted using PostgreSQL syntax, but it’s worth noting Django uses SQL tailored to the database backend specified in your settings file.

Using models¶

Once you have defined your models, you need to tell Django you’re going to use those models. Do this by editing your settings file and changing the INSTALLED_APPS setting to add the name of the module that contains your models.py.

For example, if the models for your application live in the module myapp.models (the package structure that is created for an application by the manage.py startapp script), INSTALLED_APPS should read, in part:

INSTALLED_APPS = [
    # ...
    "myapp",
    # ...
]

When you add new apps to INSTALLED_APPS, be sure to run manage.py migrate, optionally making migrations for them first with manage.py makemigrations.

Fields¶

The most important part of a model – and the only required part of a model – is the list of database fields it defines. Fields are specified by class attributes. Be careful not to choose field names that conflict with the models API like clean, save, or delete.

Example:

from django.db import models


class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)


class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()

Field types¶

Each field in your model should be an instance of the appropriate Field class. Django uses the field class types to determine a few things:

The column type, which tells the database what kind of data to store (e.g. INTEGER, VARCHAR, TEXT).

The default HTML widget to use when rendering a form field (e.g. <input type="text">, <select>).

The minimal validation requirements, used in Django’s admin and in automatically-generated forms.

Django ships with dozens of built-in field types; you can find the complete list in the model field reference. You can easily write your own fields if Django’s built-in ones don’t do the trick; see How to create custom model fields.

Field options¶

Each field takes a certain set of field-specific arguments (documented in the model field reference). For example, CharField (and its subclasses) require a max_length argument which specifies the size of the VARCHAR database field used to store the data.

There’s also a set of common arguments available to all field types. All are optional. They’re fully explained in the reference, but here’s a quick summary of the most often-used ones:

Again, these are just short descriptions of the most common field options. Full details can be found in the common model field option reference.

Automatic primary key fields¶

By default, Django gives each model an auto-incrementing primary key with the type specified per app in AppConfig.default_auto_field or globally in the DEFAULT_AUTO_FIELD setting. For example:

id = models.BigAutoField(primary_key=True)

If you’d like to specify a custom primary key, specify primary_key=True on one of your fields. If Django sees you’ve explicitly set Field.primary_key, it won’t add the automatic id column.

Each model requires exactly one field to have primary_key=True (either explicitly declared or automatically added).

Verbose field names¶

Each field type, except for ForeignKey, ManyToManyField and OneToOneField, takes an optional first positional argument – a verbose name. If the verbose name isn’t given, Django will automatically create it using the field’s attribute name, converting underscores to spaces.

In this example, the verbose name is "person's first name":

first_name = models.CharField("person's first name", max_length=30)

In this example, the verbose name is "first name":

first_name = models.CharField(max_length=30)

ForeignKey, ManyToManyField and OneToOneField require the first argument to be a model class, so use the verbose_name keyword argument:

poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
)
sites = models.ManyToManyField(Site, verbose_name="list of sites")
place = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    verbose_name="related place",
)

The convention is not to capitalize the first letter of the verbose_name. Django will automatically capitalize the first letter where it needs to.

Relationships¶

Clearly, the power of relational databases lies in relating tables to each other. Django offers ways to define the three most common types of database relationships: many-to-one, many-to-many and one-to-one.

Many-to-one relationships¶

To define a many-to-one relationship, use django.db.models.ForeignKey. You use it just like any other Field type: by including it as a class attribute of your model.

ForeignKey requires a positional argument: the class to which the model is related.

For example, if a Car model has a Manufacturer – that is, a Manufacturer makes multiple cars but each Car only has one Manufacturer – use the following definitions:

from django.db import models


class Manufacturer(models.Model):
    # ...
    pass


class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...

You can also create recursive relationships (an object with a many-to-one relationship to itself) and relationships to models not yet defined; see the model field reference for details.

It’s suggested, but not required, that the name of a ForeignKey field (manufacturer in the example above) be the name of the model, lowercase. You can call the field whatever you want. For example:

class Car(models.Model):
    company_that_makes_it = models.ForeignKey(
        Manufacturer,
        on_delete=models.CASCADE,
    )
    # ...

See also

ForeignKey fields accept a number of extra arguments which are explained in the model field reference. These options help define how the relationship should work; all are optional.

For details on accessing backwards-related objects, see the Following relationships backward example.

For sample code, see the Many-to-one relationship model example.

Many-to-many relationships¶

To define a many-to-many relationship, use ManyToManyField. You use it just like any other Field type: by including it as a class attribute of your model.

ManyToManyField requires a positional argument: the class to which the model is related.

For example, if a Pizza has multiple Topping objects – that is, a Topping can be on multiple pizzas and each Pizza has multiple toppings – here’s how you’d represent that:

from django.db import models


class Topping(models.Model):
    # ...
    pass


class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)

As with ForeignKey, you can also create recursive relationships (an object with a many-to-many relationship to itself) and relationships to models not yet defined.

It’s suggested, but not required, that the name of a ManyToManyField (toppings in the example above) be a plural describing the set of related model objects.

It doesn’t matter which model has the ManyToManyField, but you should only put it in one of the models – not both.

Generally, ManyToManyField instances should go in the object that’s going to be edited on a form. In the above example, toppings is in Pizza (rather than Topping having a pizzas ManyToManyField ) because it’s more natural to think about a pizza having toppings than a topping being on multiple pizzas. The way it’s set up above, the Pizza form would let users select the toppings.

See also

See the Many-to-many relationship model example for a full example.

ManyToManyField fields also accept a number of extra arguments which are explained in the model field reference. These options help define how the relationship should work; all are optional.

Extra fields on many-to-many relationships¶

When you’re only dealing with many-to-many relationships such as mixing and matching pizzas and toppings, a standard ManyToManyField is all you need. However, sometimes you may need to associate data with the relationship between two models.

For example, consider the case of an application tracking the musical groups which musicians belong to. There is a many-to-many relationship between a person and the groups of which they are a member, so you could use a ManyToManyField to represent this relationship. However, there is a lot of detail about the membership that you might want to collect, such as the date at which the person joined the group.

For these situations, Django allows you to specify the model that will be used to govern the many-to-many relationship. You can then put extra fields on the intermediate model. The intermediate model is associated with the ManyToManyField using the through argument to point to the model that will act as an intermediary. For our musician example, the code would look something like this:

from django.db import models


class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):
        return self.name


class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through="Membership")

    def __str__(self):
        return self.name


class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)

When you set up the intermediary model, you explicitly specify foreign keys to the models that are involved in the many-to-many relationship. This explicit declaration defines how the two models are related.

There are a few restrictions on the intermediate model:

Your intermediate model must contain one - and only one - foreign key to the source model (this would be Group in our example), or you must explicitly specify the foreign keys Django should use for the relationship using ManyToManyField.through_fields. If you have more than one foreign key and through_fields is not specified, a validation error will be raised. A similar restriction applies to the foreign key to the target model (this would be Person in our example).

For a model which has a many-to-many relationship to itself through an intermediary model, two foreign keys to the same model are permitted, but they will be treated as the two (different) sides of the many-to-many relationship. If there are more than two foreign keys though, you must also specify through_fields as above, or a validation error will be raised.

Now that you have set up your ManyToManyField to use your intermediary model (Membership, in this case), you’re ready to start creating some many-to-many relationships. You do this by creating instances of the intermediate model:

>>> ringo = Person.objects.create(name="Ringo Starr")
>>> paul = Person.objects.create(name="Paul McCartney")
>>> beatles = Group.objects.create(name="The Beatles")
>>> m1 = Membership(
...     person=ringo,
...     group=beatles,
...     date_joined=date(1962, 8, 16),
...     invite_reason="Needed a new drummer.",
... )
>>> m1.save()
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>]>
>>> ringo.group_set.all()
<QuerySet [<Group: The Beatles>]>
>>> m2 = Membership.objects.create(
...     person=paul,
...     group=beatles,
...     date_joined=date(1960, 8, 1),
...     invite_reason="Wanted to form a band.",
... )
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>

You can also use add(), create(), or set() to create relationships, as long as you specify through_defaults for any required fields:

>>> beatles.members.add(john, through_defaults={"date_joined": date(1960, 8, 1)})
>>> beatles.members.create(
...     name="George Harrison", through_defaults={"date_joined": date(1960, 8, 1)}
... )
>>> beatles.members.set(
...     [john, paul, ringo, george], through_defaults={"date_joined": date(1960, 8, 1)}
... )

You may prefer to create instances of the intermediate model directly.

If the custom through table defined by the intermediate model does not enforce uniqueness on the (model1, model2) pair, allowing multiple values, the remove() call will remove all intermediate model instances:

>>> Membership.objects.create(
...     person=ringo,
...     group=beatles,
...     date_joined=date(1968, 9, 4),
...     invite_reason="You've been gone for a month and we miss you.",
... )
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>, <Person: Ringo Starr>]>
>>> # This deletes both of the intermediate model instances for Ringo Starr
>>> beatles.members.remove(ringo)
>>> beatles.members.all()
<QuerySet [<Person: Paul McCartney>]>

The clear() method can be used to remove all many-to-many relationships for an instance:

>>> # Beatles have broken up
>>> beatles.members.clear()
>>> # Note that this deletes the intermediate model instances
>>> Membership.objects.all()
<QuerySet []>

Once you have established the many-to-many relationships, you can issue queries. Just as with normal many-to-many relationships, you can query using the attributes of the many-to-many-related model:

# Find all the groups with a member whose name starts with 'Paul'
>>> Group.objects.filter(members__name__startswith="Paul")
<QuerySet [<Group: The Beatles>]>

As you are using an intermediate model, you can also query on its attributes:

# Find all the members of the Beatles that joined after 1 Jan 1961
>>> Person.objects.filter(
...     group__name="The Beatles", membership__date_joined__gt=date(1961, 1, 1)
... )
<QuerySet [<Person: Ringo Starr]>

If you need to access a membership’s information you may do so by directly querying the Membership model:

>>> ringos_membership = Membership.objects.get(group=beatles, person=ringo)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason
'Needed a new drummer.'

Another way to access the same information is by querying the many-to-many reverse relationship from a Person object:

>>> ringos_membership = ringo.membership_set.get(group=beatles)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason
'Needed a new drummer.'

One-to-one relationships¶

To define a one-to-one relationship, use OneToOneField. You use it just like any other Field type: by including it as a class attribute of your model.

This is most useful on the primary key of an object when that object “extends” another object in some way.

OneToOneField requires a positional argument: the class to which the model is related.

For example, if you were building a database of “places”, you would build pretty standard stuff such as address, phone number, etc. in the database. Then, if you wanted to build a database of restaurants on top of the places, instead of repeating yourself and replicating those fields in the Restaurant model, you could make Restaurant have a OneToOneField to Place (because a restaurant “is a” place; in fact, to handle this you’d typically use inheritance, which involves an implicit one-to-one relation).

As with ForeignKey, a recursive relationship can be defined and references to as-yet undefined models can be made.

See also

See the One-to-one relationship model example for a full example.

OneToOneField fields also accept an optional parent_link argument.

OneToOneField classes used to automatically become the primary key on a model. This is no longer true (although you can manually pass in the primary_key argument if you like). Thus, it’s now possible to have multiple fields of type OneToOneField on a single model.

Models across files¶

It’s perfectly OK to relate a model to one from another app. To do this, import the related model at the top of the file where your model is defined. Then, refer to the other model class wherever needed. For example:

from django.db import models
from geography.models import ZipCode


class Restaurant(models.Model):
    # ...
    zip_code = models.ForeignKey(
        ZipCode,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )

Field name restrictions¶

Django places some restrictions on model field names:

A field name cannot be a Python reserved word, because that would result in a Python syntax error. For example:

class Example(models.Model):
    pass = models.IntegerField() # 'pass' is a reserved word!

A field name cannot contain more than one underscore in a row, due to the way Django’s query lookup syntax works. For example:

class Example(models.Model):
    foo__bar = models.IntegerField()  # 'foo__bar' has two underscores!

A field name cannot end with an underscore, for similar reasons.

These limitations can be worked around, though, because your field name doesn’t necessarily have to match your database column name. See the db_column option.

SQL reserved words, such as join, where or select, are allowed as model field names, because Django escapes all database table names and column names in every underlying SQL query. It uses the quoting syntax of your particular database engine.

Custom field types¶

If one of the existing model fields cannot be used to fit your purposes, or if you wish to take advantage of some less common database column types, you can create your own field class. Full coverage of creating your own fields is provided in How to create custom model fields.

Meta options¶

Give your model metadata by using an inner class Meta, like so:

from django.db import models


class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"

Model metadata is “anything that’s not a field”, such as ordering options (ordering), database table name (db_table), or human-readable singular and plural names (verbose_name and verbose_name_plural). None are required, and adding class Meta to a model is completely optional.

A complete list of all possible Meta options can be found in the model option reference.

Model attributes¶

Model methods¶

Define custom methods on a model to add custom “row-level” functionality to your objects. Whereas Manager methods are intended to do “table-wide” things, model methods should act on a particular model instance.

This is a valuable technique for keeping business logic in one place – the model.

For example, this model has a few custom methods:

from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime

        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        "Returns the person's full name."
        return f"{self.first_name} {self.last_name}"

The last method in this example is a property.

The model instance reference has a complete list of methods automatically given to each model. You can override most of these – see overriding predefined model methods, below – but there are a couple that you’ll almost always want to define:

Overriding predefined model methods¶

There’s another set of model methods that encapsulate a bunch of database behavior that you’ll want to customize. In particular you’ll often want to change the way save() and delete() work.

You’re free to override these methods (and any other model method) to alter behavior.

A classic use-case for overriding the built-in methods is if you want something to happen whenever you save an object. For example (see save() for documentation of the parameters it accepts):

from django.db import models


class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        do_something()
        super().save(*args, **kwargs)  # Call the "real" save() method.
        do_something_else()

You can also prevent saving:

from django.db import models


class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        if self.name == "Yoko Ono's blog":
            return  # Yoko shall never have her own blog!
        else:
            super().save(*args, **kwargs)  # Call the "real" save() method.

It’s important to remember to call the superclass method – that’s that super().save(*args, **kwargs) business – to ensure that the object still gets saved into the database. If you forget to call the superclass method, the default behavior won’t happen and the database won’t get touched.

It’s also important that you pass through the arguments that can be passed to the model method – that’s what the *args, **kwargs bit does. Django will, from time to time, extend the capabilities of built-in model methods, adding new arguments. If you use *args, **kwargs in your method definitions, you are guaranteed that your code will automatically support those arguments when they are added.

If you wish to update a field value in the save() method, you may also want to have this field added to the update_fields keyword argument. This will ensure the field is saved when update_fields is specified. For example:

from django.db import models
from django.utils.text import slugify


class Blog(models.Model):
    name = models.CharField(max_length=100)
    slug = models.TextField()

    def save(
        self, force_insert=False, force_update=False, using=None, update_fields=None
    ):
        self.slug = slugify(self.name)
        if update_fields is not None and "name" in update_fields:
            update_fields = {"slug"}.union(update_fields)
        super().save(
            force_insert=force_insert,
            force_update=force_update,
            using=using,
            update_fields=update_fields,
        )

See Specifying which fields to save for more details.

Overridden model methods are not called on bulk operations

Note that the delete() method for an object is not necessarily called when deleting objects in bulk using a QuerySet or as a result of a cascading delete. To ensure customized delete logic gets executed, you can use pre_delete and/or post_delete signals.

Unfortunately, there isn’t a workaround when creating or updating objects in bulk, since none of save(), pre_save, and post_save are called.

Executing custom SQL¶

Another common pattern is writing custom SQL statements in model methods and module-level methods. For more details on using raw SQL, see the documentation on using raw SQL.

Model inheritance¶

Model inheritance in Django works almost identically to the way normal class inheritance works in Python, but the basics at the beginning of the page should still be followed. That means the base class should subclass django.db.models.Model.

The only decision you have to make is whether you want the parent models to be models in their own right (with their own database tables), or if the parents are just holders of common information that will only be visible through the child models.

There are three styles of inheritance that are possible in Django.

Often, you will just want to use the parent class to hold information that you don’t want to have to type out for each child model. This class isn’t going to ever be used in isolation, so Abstract base classes are what you’re after.

If you’re subclassing an existing model (perhaps something from another application entirely) and want each model to have its own database table, Multi-table inheritance is the way to go.

Finally, if you only want to modify the Python-level behavior of a model, without changing the models fields in any way, you can use Proxy models.

Abstract base classes¶

Abstract base classes are useful when you want to put some common information into a number of other models. You write your base class and put abstract=True in the Meta class. This model will then not be used to create any database table. Instead, when it is used as a base class for other models, its fields will be added to those of the child class.

An example:

from django.db import models


class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True


class Student(CommonInfo):
    home_group = models.CharField(max_length=5)

The Student model will have three fields: name, age and home_group. The CommonInfo model cannot be used as a normal Django model, since it is an abstract base class. It does not generate a database table or have a manager, and cannot be instantiated or saved directly.

Fields inherited from abstract base classes can be overridden with another field or value, or be removed with None.

For many uses, this type of model inheritance will be exactly what you want. It provides a way to factor out common information at the Python level, while still only creating one database table per child model at the database level.

Meta inheritance¶

When an abstract base class is created, Django makes any Meta inner class you declared in the base class available as an attribute. If a child class does not declare its own Meta class, it will inherit the parent’s Meta. If the child wants to extend the parent’s Meta class, it can subclass it. For example:

from django.db import models


class CommonInfo(models.Model):
    # ...
    class Meta:
        abstract = True
        ordering = ["name"]


class Student(CommonInfo):
    # ...
    class Meta(CommonInfo.Meta):
        db_table = "student_info"

Django does make one adjustment to the Meta class of an abstract base class: before installing the Meta attribute, it sets abstract=False. This means that children of abstract base classes don’t automatically become abstract classes themselves. To make an abstract base class that inherits from another abstract base class, you need to explicitly set abstract=True on the child.

Some attributes won’t make sense to include in the Meta class of an abstract base class. For example, including db_table would mean that all the child classes (the ones that don’t specify their own Meta) would use the same database table, which is almost certainly not what you want.

Due to the way Python inheritance works, if a child class inherits from multiple abstract base classes, only the Meta options from the first listed class will be inherited by default. To inherit Meta options from multiple abstract base classes, you must explicitly declare the Meta inheritance. For example:

from django.db import models


class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True
        ordering = ["name"]


class Unmanaged(models.Model):
    class Meta:
        abstract = True
        managed = False


class Student(CommonInfo, Unmanaged):
    home_group = models.CharField(max_length=5)

    class Meta(CommonInfo.Meta, Unmanaged.Meta):
        pass

Be careful with related_name and related_query_name¶

If you are using related_name or related_query_name on a ForeignKey or ManyToManyField, you must always specify a unique reverse name and query name for the field. This would normally cause a problem in abstract base classes, since the fields on this class are included into each of the child classes, with exactly the same values for the attributes (including related_name and related_query_name) each time.

To work around this problem, when you are using related_name or related_query_name in an abstract base class (only), part of the value should contain '%(app_label)s' and '%(class)s'.

'%(class)s' is replaced by the lowercased name of the child class that the field is used in.

'%(app_label)s' is replaced by the lowercased name of the app the child class is contained within. Each installed application name must be unique and the model class names within each app must also be unique, therefore the resulting name will end up being different.

For example, given an app common/models.py:

from django.db import models


class Base(models.Model):
    m2m = models.ManyToManyField(
        OtherModel,
        related_name="%(app_label)s_%(class)s_related",
        related_query_name="%(app_label)s_%(class)ss",
    )

    class Meta:
        abstract = True


class ChildA(Base):
    pass


class ChildB(Base):
    pass

Along with another app rare/models.py:

from common.models import Base


class ChildB(Base):
    pass

The reverse name of the common.ChildA.m2m field will be common_childa_related and the reverse query name will be common_childas. The reverse name of the common.ChildB.m2m field will be common_childb_related and the reverse query name will be common_childbs. Finally, the reverse name of the rare.ChildB.m2m field will be rare_childb_related and the reverse query name will be rare_childbs. It’s up to you how you use the '%(class)s' and '%(app_label)s' portion to construct your related name or related query name but if you forget to use it, Django will raise errors when you perform system checks (or run migrate).

If you don’t specify a related_name attribute for a field in an abstract base class, the default reverse name will be the name of the child class followed by '_set', just as it normally would be if you’d declared the field directly on the child class. For example, in the above code, if the related_name attribute was omitted, the reverse name for the m2m field would be childa_set in the ChildA case and childb_set for the ChildB field.

Multi-table inheritance¶

The second type of model inheritance supported by Django is when each model in the hierarchy is a model all by itself. Each model corresponds to its own database table and can be queried and created individually. The inheritance relationship introduces links between the child model and each of its parents (via an automatically-created OneToOneField). For example:

from django.db import models


class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)


class Restaurant(Place):
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)

All of the fields of Place will also be available in Restaurant, although the data will reside in a different database table. So these are both possible:

>>> Place.objects.filter(name="Bob's Cafe")
>>> Restaurant.objects.filter(name="Bob's Cafe")

If you have a Place that is also a Restaurant, you can get from the Place object to the Restaurant object by using the lowercase version of the model name:

>>> p = Place.objects.get(id=12)
# If p is a Restaurant object, this will give the child class:
>>> p.restaurant
<Restaurant: ...>

However, if p in the above example was not a Restaurant (it had been created directly as a Place object or was the parent of some other class), referring to p.restaurant would raise a Restaurant.DoesNotExist exception.

The automatically-created OneToOneField on Restaurant that links it to Place looks like this:

place_ptr = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    parent_link=True,
    primary_key=True,
)

You can override that field by declaring your own OneToOneField with parent_link=True on Restaurant.

Meta and multi-table inheritance¶

In the multi-table inheritance situation, it doesn’t make sense for a child class to inherit from its parent’s Meta class. All the Meta options have already been applied to the parent class and applying them again would normally only lead to contradictory behavior (this is in contrast with the abstract base class case, where the base class doesn’t exist in its own right).

So a child model does not have access to its parent’s Meta class. However, there are a few limited cases where the child inherits behavior from the parent: if the child does not specify an ordering attribute or a get_latest_by attribute, it will inherit these from its parent.

If the parent has an ordering and you don’t want the child to have any natural ordering, you can explicitly disable it:

class ChildModel(ParentModel):
    # ...
    class Meta:
        # Remove parent's ordering effect
        ordering = []

Inheritance and reverse relations¶

Because multi-table inheritance uses an implicit OneToOneField to link the child and the parent, it’s possible to move from the parent down to the child, as in the above example. However, this uses up the name that is the default related_name value for ForeignKey and ManyToManyField relations. If you are putting those types of relations on a subclass of the parent model, you must specify the related_name attribute on each such field. If you forget, Django will raise a validation error.

For example, using the above Place class again, let’s create another subclass with a ManyToManyField:

class Supplier(Place):
    customers = models.ManyToManyField(Place)

This results in the error:

Reverse query name for 'Supplier.customers' clashes with reverse query
name for 'Supplier.place_ptr'.

HINT: Add or change a related_name argument to the definition for
'Supplier.customers' or 'Supplier.place_ptr'.

Adding related_name to the customers field as follows would resolve the error: models.ManyToManyField(Place, related_name='provider').

Specifying the parent link field¶

As mentioned, Django will automatically create a OneToOneField linking your child class back to any non-abstract parent models. If you want to control the name of the attribute linking back to the parent, you can create your own OneToOneField and set parent_link=True to indicate that your field is the link back to the parent class.

Proxy models¶

When using multi-table inheritance, a new database table is created for each subclass of a model. This is usually the desired behavior, since the subclass needs a place to store any additional data fields that are not present on the base class. Sometimes, however, you only want to change the Python behavior of a model – perhaps to change the default manager, or add a new method.

This is what proxy model inheritance is for: creating a proxy for the original model. You can create, delete and update instances of the proxy model and all the data will be saved as if you were using the original (non-proxied) model. The difference is that you can change things like the default model ordering or the default manager in the proxy, without having to alter the original.

Proxy models are declared like normal models. You tell Django that it’s a proxy model by setting the proxy attribute of the Meta class to True.

For example, suppose you want to add a method to the Person model. You can do it like this:

from django.db import models


class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)


class MyPerson(Person):
    class Meta:
        proxy = True

    def do_something(self):
        # ...
        pass

The MyPerson class operates on the same database table as its parent Person class. In particular, any new instances of Person will also be accessible through MyPerson, and vice-versa:

>>> p = Person.objects.create(first_name="foobar")
>>> MyPerson.objects.get(first_name="foobar")
<MyPerson: foobar>

You could also use a proxy model to define a different default ordering on a model. You might not always want to order the Person model, but regularly order by the last_name attribute when you use the proxy:

class OrderedPerson(Person):
    class Meta:
        ordering = ["last_name"]
        proxy = True

Now normal Person queries will be unordered and OrderedPerson queries will be ordered by last_name.

Proxy models inherit Meta attributes in the same way as regular models.

QuerySets still return the model that was requested¶

There is no way to have Django return, say, a MyPerson object whenever you query for Person objects. A queryset for Person objects will return those types of objects. The whole point of proxy objects is that code relying on the original Person will use those and your own code can use the extensions you included (that no other code is relying on anyway). It is not a way to replace the Person (or any other) model everywhere with something of your own creation.

Base class restrictions¶

A proxy model must inherit from exactly one non-abstract model class. You can’t inherit from multiple non-abstract models as the proxy model doesn’t provide any connection between the rows in the different database tables. A proxy model can inherit from any number of abstract model classes, providing they do not define any model fields. A proxy model may also inherit from any number of proxy models that share a common non-abstract parent class.

Proxy model managers¶

If you don’t specify any model managers on a proxy model, it inherits the managers from its model parents. If you define a manager on the proxy model, it will become the default, although any managers defined on the parent classes will still be available.

Continuing our example from above, you could change the default manager used when you query the Person model like this:

from django.db import models


class NewManager(models.Manager):
    # ...
    pass


class MyPerson(Person):
    objects = NewManager()

    class Meta:
        proxy = True

If you wanted to add a new manager to the Proxy, without replacing the existing default, you can use the techniques described in the custom manager documentation: create a base class containing the new managers and inherit that after the primary base class:

# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
    secondary = NewManager()

    class Meta:
        abstract = True


class MyPerson(Person, ExtraManagers):
    class Meta:
        proxy = True

You probably won’t need to do this very often, but, when you do, it’s possible.

Differences between proxy inheritance and unmanaged models¶

Proxy model inheritance might look fairly similar to creating an unmanaged model, using the managed attribute on a model’s Meta class.

With careful setting of Meta.db_table you could create an unmanaged model that shadows an existing model and adds Python methods to it. However, that would be very repetitive and fragile as you need to keep both copies synchronized if you make any changes.

On the other hand, proxy models are intended to behave exactly like the model they are proxying for. They are always in sync with the parent model since they directly inherit its fields and managers.

The general rules are:

If you are mirroring an existing model or database table and don’t want all the original database table columns, use Meta.managed=False. That option is normally useful for modeling database views and tables not under the control of Django.

If you are wanting to change the Python-only behavior of a model, but keep all the same fields as in the original, use Meta.proxy=True. This sets things up so that the proxy model is an exact copy of the storage structure of the original model when data is saved.

Multiple inheritance¶

Just as with Python’s subclassing, it’s possible for a Django model to inherit from multiple parent models. Keep in mind that normal Python name resolution rules apply. The first base class that a particular name (e.g. Meta) appears in will be the one that is used; for example, this means that if multiple parents contain a Meta class, only the first one is going to be used, and all others will be ignored.

Generally, you won’t need to inherit from multiple parents. The main use-case where this is useful is for “mix-in” classes: adding a particular extra field or method to every class that inherits the mix-in. Try to keep your inheritance hierarchies as simple and straightforward as possible so that you won’t have to struggle to work out where a particular piece of information is coming from.

Note that inheriting from multiple models that have a common id primary key field will raise an error. To properly use multiple inheritance, you can use an explicit AutoField in the base models:

class Article(models.Model):
    article_id = models.AutoField(primary_key=True)
    ...


class Book(models.Model):
    book_id = models.AutoField(primary_key=True)
    ...


class BookReview(Book, Article):
    pass

Or use a common ancestor to hold the AutoField. This requires using an explicit OneToOneField from each parent model to the common ancestor to avoid a clash between the fields that are automatically generated and inherited by the child:

class Piece(models.Model):
    pass


class Article(Piece):
    article_piece = models.OneToOneField(
        Piece, on_delete=models.CASCADE, parent_link=True
    )
    ...


class Book(Piece):
    book_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
    ...


class BookReview(Book, Article):
    pass

Field name “hiding” is not permitted¶

In normal Python class inheritance, it is permissible for a child class to override any attribute from the parent class. In Django, this isn’t usually permitted for model fields. If a non-abstract model base class has a field called author, you can’t create another model field or define an attribute called author in any class that inherits from that base class.

This restriction doesn’t apply to model fields inherited from an abstract model. Such fields may be overridden with another field or value, or be removed by setting field_name = None.

Warning

Model managers are inherited from abstract base classes. Overriding an inherited field which is referenced by an inherited Manager may cause subtle bugs. See custom managers and model inheritance.

Note

Some fields define extra attributes on the model, e.g. a ForeignKey defines an extra attribute with _id appended to the field name, as well as related_name and related_query_name on the foreign model.

These extra attributes cannot be overridden unless the field that defines it is changed or removed so that it no longer defines the extra attribute.

Overriding fields in a parent model leads to difficulties in areas such as initializing new instances (specifying which field is being initialized in Model.__init__) and serialization. These are features which normal Python class inheritance doesn’t have to deal with in quite the same way, so the difference between Django model inheritance and Python class inheritance isn’t arbitrary.

This restriction only applies to attributes which are Field instances. Normal Python attributes can be overridden if you wish. It also only applies to the name of the attribute as Python sees it: if you are manually specifying the database column name, you can have the same column name appearing in both a child and an ancestor model for multi-table inheritance (they are columns in two different database tables).

Django will raise a FieldError if you override any model field in any ancestor model.

Note that because of the way fields are resolved during class definition, model fields inherited from multiple abstract parent models are resolved in a strict depth-first order. This contrasts with standard Python MRO, which is resolved breadth-first in cases of diamond shaped inheritance. This difference only affects complex model hierarchies, which (as per the advice above) you should try to avoid.

Organizing models in a package¶

The manage.py startapp command creates an application structure that includes a models.py file. If you have many models, organizing them in separate files may be useful.

To do so, create a models package. Remove models.py and create a myapp/models/ directory with an __init__.py file and the files to store your models. You must import the models in the __init__.py file.

For example, if you had organic.py and synthetic.py in the models directory:

myapp/models/__init__.py¶

from .organic import Person
from .synthetic import Robot

Explicitly importing each model rather than using from .models import * has the advantages of not cluttering the namespace, making code more readable, and keeping code analysis tools useful.

See also

Back to Top
Task management

العربية

Català

Deutsch

فارسی

日本語

Norsk bokmål

Tiếng Việt

粵語

Edit links

From Wikipedia, the free encyclopedia

Process of managing a task through its life cycle

Not to be confused with Task manager.

Task management is the process of overseeing a task through its lifecycle. It involves planning, testing, tracking, and reporting. Task management can help individuals achieve goals or enable groups of individuals to collaborate and share knowledge for the accomplishment of collective goals.[1] Tasks are also differentiated by complexity, from low to high.[1]

Effective task management requires overseeing all aspects of a task, including its status, priority, time, human and financial resource assignments, recurrence, dependencies, notifications, etc. These can be lumped together broadly as the fundamental activities of task management.

Managing tasks for multiple individuals or teams can be facilitated by specialized software, such as workflow or project-management software. This type of software is sometimes referred to as a productivity system.[citation needed]

Task management may be a component of project management and process management, serving as the foundation for efficient workflow within an organization. Project managers adhering to task-oriented management have a detailed and up-to-date project schedule and are usually good at directing team members and moving the project forward.[2]

Task lifecycle

[edit]

The status of tasks can be described by these states:

Ready

Assigned

Terminated

Expired

Forwarded

Started

Finished

Verified

Paused

Failed

The state machine diagram to the right is referenced from IBM and describes different states of a task over its lifecycle.[3] A more up-to-date task-state machine diagram, which is applicable to the modern continuous delivery method, has also been published.[4]

Activities supported by tasks

[edit]

As a discipline, task management embraces several key activities. Various conceptual breakdowns exist, at a high level, these always include creative, functional, project, performance, and service activities.

Creative activities pertain to task creation. In this context, they should facilitate task planning, brainstorming, creation, elaboration, clarification, organization, reduction, targeting, and preliminary prioritization.

Functional activities pertain to personnel, sales, quality, or other management areas, ultimately ensuring the production of final goods and services for delivery to customers. Within this context, these activities should enable planning, reporting, tracking, prioritizing, configuring, delegating, and managing tasks.

Project activities pertain to planning and time and cost reporting. While these activities may involve multiple functional aspects, they are always more significant and purposeful than the sum of their parts. In context, project activities should support project task breakdown (also known as work breakdown structure), task allocation, inventory across projects, and concurrent access to task databases.

Service activities pertain to client and internal company-services provision, including customer relationship management and knowledge management. In context, they should support file attachments and links to tasks, document management, access rights management, inventory of client and employee records, orders and calls management, and annotating tasks.

Performance activities pertain to tracking performance and fulfillment of assigned tasks. In context, these should allow for tracking by time, cost control, stakeholders, priority, charts, exportable reports, status updates, deadline adjustments, and activity logging.

Report activities involve presenting information regarding the other five activities listed, including graphical displays.

Software

[edit]

Main category: Task management software

Task management software tools abound in the marketplace. Some are free, while others are intended for enterprise-wide deployment purposes. Some are simple to-do lists, while others boast enterprise-wide task creation, visualization, and notification capabilities, among other features. Task management is used by small to Fortune 100-sized companies. It does support simple individual projects to corporate task management activities.

Project management software, calendaring software, and workflow software often include advanced task management features, supporting a variety of task-related activities within a comprehensive software environment. These functionalities complement the numerous project and performance tasks integrated into high-quality enterprise-level task management software products.

Key software dimensions that intersect across various lines of task management products include task creation, task visualization, notifications, resource assignment, compatibility, configurability, scalability, and reporting.

Task creation encompasses collaborative capabilities for turning ideas into actions (tasks). This includes activities involved in defining the task and encompasses the collaboration needed in the planning process.

Task visualization involves presenting tasks, most often in time and list forms. Priority visualization encompasses classification (e.g., budget, time, stakeholder) and mechanism (e.g., color code or text). Calendaring covers scheduling (e.g., availability, meetings, appointments, and other potential conflicts) and notifications.

Notifications encompass configurable settings for informing past, present, and pending deadlines.

Assigning resource encompasses the ability to delegate tasks and tools to single or multiple people.

Compatibility encompasses the ability of a task management environment to connect to other systems, software, and environments. It includes setting a structure and restrictions on communication going from the task management environment to other software, systems, and environments.

Configurability encompasses the ability to add, remove, and manage functionality and usability in task management environments.

Scalability encompasses the ability to perform a task properly when there is a change in the quantity of users to meet the specific task requirements.

Reporting encompasses presenting information by displaying it either in a tabular or graphical display.

See also

[edit]

Gantt chart

Digital calendar

Time blocking

Issue tracking system

Milestone (project management)

Outline of management

Time management

Time-tracking software

Work breakdown structure

Workers' self-management

References

[edit]

^ Jump up to: a b Maus, Heiko, M.P. van der Aalst, Wil, Rickayzen, Alan, Riss, Uwe. V. “Challenges for Business Processes and Task Management,” Journal of Universal Knowledge Management. Volume 0, Issue 2, 2005.

^ Thomas Cutting "Relationship vs. Task Oriented Management". 3 March 2010 http://www.pmhut.com/relationship-vs-task-oriented-management

^ Jump up to: a b "Life Cycle of Human Tasks". IBM WebSphere Process Server documentation. IBM. Retrieved 6 Mar 2024.

^ "Anatomy of a task". Archived from the original on 2018-02-04.

hide v t e Task management software and project management software Active Airtable Any.do Asana Basecamp ClickUp Easy Redmine Evernote Google Tasks Habitica Jira ManagePro Microsoft Planner Microsoft To Do Monday.com Notion Novell GroupWise OmniFocus Priority Matrix Remember the Milk Reminders ShotGrid Slack TaskCracker TaskJuggler Taskwarrior Taskworld Teamwork Things Trello Workflowy YouTrack Discontinued IQTELL Springpad Wunderlist Category

Retrieved from "https://en.wikipedia.org/w/index.php?title=Task_management&oldid=1283705082"

Categories:

Management by type

Labor

Hidden categories:

Articles with short description

Short description matches Wikidata

All articles with unsourced statements

Articles with unsourced statements from November 2022
Time management

Afrikaans

العربية

Azərbaycanca

Беларуская

Беларуская (тарашкевіца)

Български

Bosanski

Čeština

Dansk

Deutsch

Eesti

Español

Esperanto

فارسی

Français

ગુજરાતી

한국어

Հայերեն

हिन्दी

Bahasa Indonesia

Italiano

עברית

ಕನ್ನಡ

Қазақша

Magyar

Nederlands

日本語

Polski

Português

Română

Русский

Simple English

Slovenčina

Slovenščina

کوردی

Српски / srpski

Svenska

தமிழ்

ไทย

Türkçe

Українська

اردو

Tiếng Việt

粵語

中文

Edit links

From Wikipedia, the free encyclopedia

Planning time spent on specific activities

"Time allocation" redirects here. For time allocation surveys, see Time-use research.

It has been suggested that P and R measures be merged into this article. ( Discuss ) Proposed since January 2025.

This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( December 2021 ) ( Learn how and when to remove this message )

Time management is the process of planning and exercising conscious control of time spent on specific activities—especially to increase effectiveness, efficiency and productivity.[1]

Time management involves demands relating to work, social life, family, hobbies, personal interests and commitments. Using time effectively gives people more choices in managing activities.[2] Time management may be aided by a range of skills, tools and techniques, especially when accomplishing specific tasks, projects and goals complying with a due date.[3]

Initially, the term time management encompassed only business and work activities, but eventually the term comprised personal activities as well. A time management system is a designed combination of processes, tools, techniques and methods. Time management is usually a necessity in managing projects, as it determines the project completion time and scope.

Cultural views

[edit]

Differences in the way a culture views time can affect the way their time is managed. For example, a linear time view is a way of conceiving time as flowing from one moment to the next in a linear fashion. This linear perception of time is predominant in America along with most Northern European countries, such as Germany, Switzerland and England.[4] People in these cultures tend to place a large value on productive time management and tend to avoid decisions or actions that would result in wasted time.[4] This linear view of time correlates to these cultures being more monochronic, or preferring to do only one thing at a time. As a result, this focus on efficiency often leads to a culture of punctuality and a strong emphasis on meeting deadlines.[5]

Another cultural time view is the multi-active time view. In multi-active cultures, most people feel that the more activities or tasks being done at once the better. This creates a sense of happiness.[4] Multi-active cultures are "polychronic" or prefer to do multiple tasks at once. This multi-active time view is prominent in most Southern European countries such as Spain, Portugal and Italy.[4] In these cultures, people often tend to spend time on things they deem to be more important such as placing a high importance on finishing social conversations.[4] In business environments, they often pay little attention to how long meetings last and instead focus on having high-quality meetings. In general, the cultural focus tends to be on synergy and creativity over efficiency.[6]

A final cultural time view is a cyclical time view. In cyclical cultures, time is considered neither linear nor event related. Because days, months, years, seasons, and events happen in regular repetitive occurrences, time is viewed as cyclical. In this view, time is not seen as wasted because it will always come back later, hence there is an unlimited amount of it.[4] This cyclical time view is prevalent throughout most countries in Asia, including Japan and China. It is more important in cultures with cyclical concepts of time to focus on completing tasks correctly, thus most people will spend more time thinking about decisions and the impact they will have, before acting on their plans.[6] Most people in cyclical cultures tend to understand that other cultures have different perspectives of time and are cognizant of this when acting on a global stage.[7] Consequently, this awareness often leads to a greater emphasis on relationships and the quality of interactions over strict adherence to schedules.[8]

Over time, the concept of time management has changed from simple tools like checklists to more complex techniques that emphasize setting priorities and coordinating tasks with objectives and values. The third generation of time management places a strong emphasis on setting objectives, organizing each day, and ranking tasks according to importance. A fourth generation has emerged, focusing on self-management rather than just managing time. It highlights the importance of managing expectations, relationships, and results, distinguishing between urgent and important tasks. Effective time management involves using personalized tools that cater to individual needs and planning in weekly terms to prioritize goals and adapt to unexpected events. Success in today's work environment depends on utilizing the right tools and strategies to achieve goals efficiently.[9][dead link]

Neuropsychology

[edit]

Excessive and chronic inability to manage time effectively may result from attention deficit hyperactivity disorder (ADHD).[10] Diagnostic criteria include a sense of underachievement, difficulty getting organized, trouble getting started, trouble managing many simultaneous projects, and trouble with follow-through.[11]

Setting priorities and goals

[edit]

These goals are recorded and may be broken down into a project, an action plan or a simple task list. For individual tasks or for goals, an importance rating may be established. Deadlines may be set and priorities assigned. This process results in a plan with a task list, schedule or calendar of activities. Authors may recommend daily, weekly, monthly or other planning periods, associated with different scope of planning or review. This is done in various ways, as follows:

ABC analysis

[edit]

The ABC method for time management developed by Alan Lakein involves categorizing tasks into three labels: A, B, and C.

Pareto analysis

[edit]

Main article: Pareto analysis

The Pareto principle is the idea that 80% of consequences come from 20% of causes. Applied to productivity, it means that 80% of results can be achieved by doing 20% of tasks.[12] If productivity is the aim of time management, then these tasks should be prioritized higher.[13]

Eisenhower method

[edit]

See also: PICK chart and MoSCoW method

The Eisenhower method or Eisenhower principle is a method that utilizes the principles of importance and urgency to organize priorities and workload. This method stems from a quote attributed to Dwight D. Eisenhower: "I have two kinds of problems, the urgent and the important. The urgent are not important, and the important are never urgent."[14] Eisenhower did not claim this insight for his own, but attributed it to an unnamed "former college president."[15]

Using the Eisenhower decision principle, tasks are evaluated using the criteria important/unimportant and urgent/not urgent,[16][17] and then placed in according quadrants in an Eisenhower matrix (also known as an Eisenhower box or Eisenhower decision matrix"[18]). Tasks in the quadrants are then handled as follows.

Important/Urgent quadrant tasks are done immediately and personally[19] e.g. crises, deadlines, problems.[18]

Important/Not Urgent quadrant tasks get an end date and are done personally,[19] e.g. relationships, planning, recreation.[18]

Unimportant/Urgent quadrant tasks are delegated,[19] e.g. interruptions, meetings, activities.[18]

Unimportant/Not Urgent quadrant tasks are dropped,[19] e.g. time wasters, pleasant activities, trivia.[18]

Implementation of goals

[edit]

"To do" redirects here. For the auxiliary use of the verb "to do" in the English language, see Do-support.

See also: shopping list

A task list (also called a to-do list or "things-to-do") is a list of tasks to be completed such as chores or steps toward completing a project. It is an inventory tool which serves as an alternative or supplement to memory.

Task lists are used in self-management, business management, project management and software development. It may involve more than one list.

When one of the items on a task list is accomplished, the task is checked or crossed off. The traditional method is to write these on a piece of paper with a pen or pencil, usually on a note pad or clip-board. Task lists can also have the form of paper or software checklists.

Writer Julie Morgenstern suggests "do's and don'ts" of time management that include:

Map out everything that is important, by making a task list.

Create "an oasis of time" for one to manage.

Say "No".

Set priorities.

Do not drop everything.

Do not think a critical task will get done in one's spare time.[20]

Numerous digital equivalents are now available, including personal information management (PIM) applications, smartphone apps, and web-based task list applications, many of which are free.

Task list organization

[edit]

Task lists are often diarized (notes written in a diary) and tiered (having rows of organized notes). The simplest tiered system includes a general to-do list (or task-holding file) to record all the tasks the person needs to accomplish and a daily to-do list which is created each day by transferring tasks from the general to-do list. An alternative is to create a "not-to-do list", to avoid unnecessary tasks.[20]

Task lists are often prioritized in the following ways.

A daily list of things to do, numbered in the order of their importance and done in that order one at a time as daily time allows, is attributed to consultant Ivy Lee (1877–1934) as the most profitable advice received by Charles M. Schwab (1862–1939), president of the Bethlehem Steel Corporation.[21][22][23]

An early advocate of "ABC" prioritization was Alan Lakein, in 1973. In his system "A" items were the most important ("A-1" the most important within that group), "B" next most important, "C" least important.[24]

A particular method of applying the ABC method[25] assigns "A" to tasks to be done within a day, "B" a week, and "C" a month.

To prioritize a daily task list, one either records the tasks in the order of highest priority, or assigns them a number after they are listed ("1" for highest priority, "2" for second highest priority, etc.) which indicates in which order to execute the tasks. The latter method is generally faster, allowing the tasks to be recorded more quickly.[20]

Another way of prioritizing compulsory tasks (group A) is to put the most unpleasant one first. When it is done, the rest of the list feels easier. Groups B and C can benefit from the same idea, but instead of doing the first task (which is the most unpleasant) right away, it gives motivation to do other tasks from the list to avoid the first one.

Various writers have stressed potential difficulties with to-do lists such as the following.

Management of the list can take over from implementing it. This could be caused by procrastination by prolonging the planning activity. This is akin to analysis paralysis. As with any activity, there's a point of diminishing returns.

To remain flexible, a task system must allow for disaster. A company must be ready for a disaster. Even if it is a small disaster, if no one made time for this situation, it can metastasize, potentially causing damage to the company.[26]

To avoid getting stuck in a wasteful pattern, the task system should also include regular (monthly, semi-annual, and annual) planning and system-evaluation sessions, to weed out inefficiencies and ensure the user is headed in the direction he or she truly desires.[27]

If some time is not regularly spent on achieving long-range goals, the individual may get stuck in a perpetual holding pattern on short-term plans, like staying at a particular job much longer than originally planned.[28]

Software applications

[edit]

Many companies use time tracking software to track an employee's working time, billable hours, etc., e.g. law practice management software.

Many software products for time management support multiple users. They allow the person to give tasks to other users and use the software for communication and to prioritize tasks.

Task-list applications may be thought of as lightweight personal information manager or project management software.

Modern task list applications may have built-in task hierarchy (tasks are composed of subtasks which again may contain subtasks), may support multiple methods of filtering and ordering the list of tasks, and may allow one to associate arbitrarily long notes for each task.[citation needed]

Time management systems

[edit]

Time management systems often include a time clock or web-based application used to track an employee's work hours. Time management systems give employers insights into their workforce, allowing them to see, plan and manage employees' time. Doing so allows employers to manage labor costs and increase productivity. A time management system automates processes, which eliminates paperwork and tedious tasks.

GTD (Getting Things Done)

[edit]

This section does not cite any sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . ( November 2024 ) ( Learn how and when to remove this message )

The Getting Things Done method, created by David Allen, is to finish small tasks immediately and for large tasks to be divided into smaller tasks to start completing now.[29] The thrust of GTD is to encourage the user to get their tasks and ideas out and on paper and organized as quickly as possible so they are easy to see and manage. "The truth is, it takes more energy to keep something inside your head than outside," says Allen.[29][30]

Pomodoro

[edit]

Francesco Cirillo's "Pomodoro Technique" was originally conceived in the late 1980s and gradually refined until it was later defined in 1992. The technique is the namesake of a Pomodoro (Italian for tomato) shaped kitchen timer initially used by Cirillo during his time at university. The "Pomodoro" is described as the fundamental metric of time within the technique and is traditionally defined as being 30 minutes long, consisting of 25 minutes of work and 5 minutes of break time. Cirillo also recommends a longer break of 15 to 30 minutes after every four Pomodoros. Through experimentation involving various workgroups and mentoring activities, Cirillo determined the "ideal Pomodoro" to be 20–35 minutes long.[31]

Related concepts

[edit]

Time management is related to the following concepts.

Return on time invested: Effective time management is essential for maximizing Return on Time Invested (ROTI). By prioritizing tasks and organizing schedules, individuals can ensure that time is allocated to activities yielding the highest value.

Project management: Time management can be considered to be a project management subset and is more commonly known as project planning and project scheduling. Time management has also been identified as one of the core functions identified in project management.[32]

Attention management relates to the management of cognitive resources, and in particular, the time that humans allocate their mind (and organize the minds of their employees) to conduct some activities.

Timeblocking is a time management strategy that specifically advocates for allocating chunks of time to dedicated tasks in order to promote deeper focus and productivity.

See also

[edit]

Attention management

Chronemics

Goal setting

Interruption science

Order

Procrastination

Professional organizing

Project management

Prospective memory

Punctuality

Scientific management

Task management

Time perception

Time-tracking software

Workforce management

References

[edit]

^ "TIME MANAGEMENT | Definition".

^ Stella Cottrell (2013). The Study Skills Handbook by Stella Cottrell (University of Leeds). Palgrave Macmillan. pp. 123+. ISBN 978-1-137-28926-1.[permanent dead link]

^ "Time Management: 10 Strategies for Better Time Management". extension.uga.edu. Retrieved 2024-10-31.

^ Jump up to: a b c d e f Communications, Richard Lewis (internationally renowned linguist). "How Different Cultures Understand Time". Business Insider. Retrieved 2018-12-04.

^ Draguns, Juris G. (2007-02-26). "Culture's Impact at the Workplace and Beyond". Reviews in Anthropology. 36 (1): 43–58. doi:10.1080/00938150601177579. ISSN 0093-8157.

^ Jump up to: a b Pant, Bhaskar (2016-05-23). "How various cultures perceive deadlines varies". Harvard Business Review. Retrieved 2018-12-04.

^ Duranti, Giancarlo; Di Prata, Olvers (2009). "Everything is about time: does it have the same meaning all over the world?".

^ Dennis, Philip A.; Hall, Edward T. (1984). "The Dance of Life: The Other Dimension of Time". Ethnohistory. 31 (4): 309. doi:10.2307/482722. ISSN 0014-1801. JSTOR 482722.

^ Thomack, Bill (2012-05-01). "Time Management for Today's Workplace Demands". Workplace Health & Safety. 60 (5): 201–203. doi:10.3928/21650799-20120426-05. ISSN 2165-0799. PMID 22587696.

^ "NIMH – Attention Deficit Hyperactivity Disorder". www.nimh.nih.gov. Archived from the original on 2016-12-29. Retrieved 2018-01-05.

^ Hallowell, Edward M.; Ratey, John J. (1994). Driven To Distraction: Recognizing and Coping with Attention Deficit Disorder from Childhood Through Adulthood. Touchstone. pp. 73–76. ISBN 9780684801285. Retrieved 2013-07-30.

^ "The 80/20 Rule And How It Can Change Your Life". Forbes. Archived from the original on 2017-11-17. Retrieved 2017-09-16.

^ Ferriss, Timothy. (2007). The 4-hour workweek: escape 9-5, live anywhere, and join the new rich (1st ed.). New York: Crown Publishers. ISBN 978-0-307-35313-9. OCLC 76262350.

^ Dwight D. Eisenhower (August 19, 1954). Address at the Second Assembly of the World Council of Churches. Archived from the original on 2015-04-02. Evanston, Illinois. (retrieved 31 March 2015.)

^ Background on the Eisenhower quote and citations to how it was picked up in media references afterwards are detailed in: O'Toole, Garson (9 May 2014). "What Is Important Is Seldom Urgent and What Is Urgent Is Seldom Important". Quote Investigator. Archived from the original on 11 April 2015.

^ Fowler, Nina (September 5, 2012). "App of the week: Eisenhower, the to-do list to keep you on task". Venture Village.

^ Drake Baer (April 10, 2014), "Dwight Eisenhower Nailed A Major Insight About Productivity" Archived 2015-04-02 at the Wayback Machine, Business Insider, (accessed 31 March 2015)

^ Jump up to: a b c d e McKay; Brett; Kate (October 23, 2013). "The Eisenhower Decision Matrix: How to Distinguish Between Urgent and Important Tasks and Make Real Progress in Your Life". A Man's Life, Personal Development. Archived from the original on 2014-03-22. Retrieved 2014-03-22.

^ Jump up to: a b c d "The Eisenhower Method". fluent-time-management.com. Archived from the original on 2014-03-03.

^ Jump up to: a b c Morgenstern, Julie (2004). Time Management from the Inside Out: The Foolproof System for Taking Control of Your Schedule—and Your Life (2nd ed.). New York: Henry Holt/Owl Books. p. 285. ISBN 0-8050-7590-9.

^ Mackenzie, Alec (1972). The Time Trap (3rd ed.). AMACOM - A Division of American Management Association. pp. 41–42. ISBN 081447926X.

^ LeBoeuf, Michael (1979). Working Smart. Warner Books. pp. 52–54. ISBN 0446952737.

^ Nightingale, Earl (1960). "Session 11. Today's Greatest Adventure". Lead the Field (unabridged audio program). Nightingale-Conant. Archived from the original on 2013-01-08.

^ Lakein, Alan (1973). How to Get Control of Your Time and Your Life. New York: P.H. Wyden. ISBN 0-451-13430-3.

^ "Time Scheduling and Time Management for dyslexic students". Dyslexia at College. Archived from the original on 2005-10-26. Retrieved October 31, 2005. — ABC lists and tips for dyslexic students on how to manage to-do lists

^ Horton, Thomas. New York The CEO Paradox (1992)

^ "Tyranny of the Urgent" essay by Charles Hummel 1967

^ "86 Experts Reveal Their Best Time Management Tips". Archived from the original on March 3, 2017. Retrieved March 3, 2017.

^ Jump up to: a b Hammersley, Ben (September 28, 2005). "Meet the man who can bring order to your universe". The Guardian. London: Guardian News and Media Limited. Retrieved March 5, 2010.

^ Ferrari, Joseph R. (August 2015). "Getting Things Done On Time". Oxford Clinical Psychology. doi:10.1093/med:psych/9780195130447.003.0002.

^ Cirillo, Francesco (2018-08-14). The Pomodoro Technique: The Acclaimed Time-Management System That Has Transformed How We Work. Crown. ISBN 978-1-5247-6071-7.

^ Project Management Institute (2004). A Guide to the Project Management Body of Knowledge (PMBOK Guide). Project Management Institute. ISBN 1-930699-45-X.

Further reading

[edit]

Library resources about Time management

Resources in your library

Resources in other libraries

Allen, David (2001). Getting things done: the Art of Stress-Free Productivity. New York: Viking. ISBN 978-0-670-88906-8.

Fiore, Neil A (2006). The Now Habit: A Strategic Program for Overcoming Procrastination and Enjoying Guilt- Free Play. New York: Penguin Group. ISBN 978-1-58542-552-5.

Le Blanc, Raymond (2008). Achieving Objectives Made Easy! Practical goal setting tools & proven time management techniques. Maarheeze: Cranendonck Coaching. ISBN 978-90-79397-03-7.

Secunda, Al (1999). The 15 second principle: short, simple steps to achieving long-term goals. New York: New York: Berkley Books. p. 157. ISBN 0-425-16505-1.{{cite book}}: CS1 maint: publisher location (link)

Burkeman, Oliver (2021). Four Thousand Weeks. Time Management for Mortals, Farrar, Straus and Giroux. 978–0374159122

“Merriam-Webster Dictionary.” Merriam-Webster.com, 2024, www.merriam-webster.com/dictionary/diarize.

“Merriam-Webster Dictionary.” Merriam-Webster.com, 30 July 2024, www.merriam-webster.com/dictionary/tiered.



Look up time management in Wiktionary, the free dictionary.



Wikiquote has quotations related to Time management.

show v t e Management Outline of management Index of management articles By type of organization Academic Association Business Restaurant Court Healthcare Intelligence Military Public Reputation By focus, within an organization On scope Strategic (top-level) Capability Capital Change Communication Financial Innovation Legal Performance Risk Systems On component Facility Product Product lifecycle Brand Project Construction Program On activity or department managed Line Marketing Operations / production Process Quality Sales Staff Accounting Office Records On aspect or relationship Customer relationship Engineering Logistics Perception Supply chain Talent On problem Conflict Crisis Stress On resource Environmental resource Field inventory Human resources Information Information technology Knowledge Land Materials Skills Technology Time Positions Interim Middle Senior Methods, approaches Adhocracy Collaborative method Distributed Earned value management Evidence-based management Full range leadership model Management by objectives Management style Macromanagement Micromanagement Scientific management Social entrepreneurship Sustainable management Team building Virtual management Skills, activities Decision-making Forecasting Leadership Pioneers, scholars Peter Drucker Eliyahu M. Goldratt Oliver E. Williamson Education Business school Certified Business Manager Chartered Management Institute Critical management studies Degrees Bachelor of Business Administration Master of Business Administration PhD in management Doctor of Business Administration Other Administration Collaboration Corporate governance Executive compensation Management consulting Management control Management cybernetics Management development Management fad Management system Managerial economics Managerial psychology Managerialism Organization development Organizational behavior management Pointy-haired Boss Systems science portal

Authority control databases : National Germany Czech Republic Latvia Israel

Retrieved from "https://en.wikipedia.org/w/index.php?title=Time_management&oldid=1286537231"

Categories:

Time management

Management systems

Hidden categories:

All articles with dead external links

Articles with dead external links from August 2023

Articles with permanently dead external links

Webarchive template wayback links

Articles with short description

Short description is different from Wikidata

Articles to be merged from January 2025

All articles to be merged

Articles needing additional references from December 2021

All articles needing additional references

Articles with dead external links from February 2025

All articles with unsourced statements

Articles with unsourced statements from October 2021

Articles needing additional references from November 2024

CS1 maint: publisher location